#include <array>
#include <cstdint>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <optional>
#include <string>
#include <pyc/cpp/pyc_tb.hpp>
#include <pyc/cpp/pyc_trace_export.hpp>

// Generated by `pyc-compile --emit=cpp`.
#include "linx_cpu_pyc_gen.hpp"

using pyc::cpp::Testbench;
using pyc::cpp::Wire;

namespace {

constexpr std::uint64_t kBootPc = 0x0000'0000'0001'0000ull;
constexpr std::uint64_t kBootSp = 0x0000'0000'0002'0000ull;

constexpr std::uint32_t ST_IF = 0;
constexpr std::uint32_t ST_ID = 1;
constexpr std::uint32_t ST_EX = 2;
constexpr std::uint32_t ST_MEM = 3;
constexpr std::uint32_t ST_WB = 4;

constexpr std::uint32_t OP_INVALID = 0;
constexpr std::uint32_t OP_C_BSTART_STD = 1;
constexpr std::uint32_t OP_C_BSTOP = 2;
constexpr std::uint32_t OP_C_MOVR = 3;
constexpr std::uint32_t OP_C_LWI = 4;
constexpr std::uint32_t OP_C_SWI = 5;
constexpr std::uint32_t OP_SUBI = 6;
constexpr std::uint32_t OP_ADDI = 7;
constexpr std::uint32_t OP_ADDIW = 8;
constexpr std::uint32_t OP_LWI = 9;
constexpr std::uint32_t OP_SWI = 10;
constexpr std::uint32_t OP_ADDW = 11;
constexpr std::uint32_t OP_ORW = 12;
constexpr std::uint32_t OP_ANDW = 13;
constexpr std::uint32_t OP_XORW = 14;
constexpr std::uint32_t OP_CMP_EQ = 15;
constexpr std::uint32_t OP_CSEL = 16;
constexpr std::uint32_t OP_HL_LUI = 17;
constexpr std::uint32_t OP_EBREAK = 18;
constexpr std::uint32_t OP_C_BSTART_COND = 19;
constexpr std::uint32_t OP_BSTART_STD_CALL = 20;
constexpr std::uint32_t OP_C_MOVI = 21;
constexpr std::uint32_t OP_C_SETRET = 22;
constexpr std::uint32_t OP_C_SETC_EQ = 23;
constexpr std::uint32_t OP_C_SETC_TGT = 24;
constexpr std::uint32_t OP_ADDTPC = 25;
constexpr std::uint32_t OP_SDI = 26;

static const char *opName(std::uint32_t op) {
  switch (op) {
  case OP_INVALID:
    return "INVALID";
  case OP_C_BSTART_STD:
    return "C.BSTART.STD";
  case OP_C_BSTOP:
    return "C.BSTOP";
  case OP_C_MOVR:
    return "C.MOVR";
  case OP_C_LWI:
    return "C.LWI";
  case OP_C_SWI:
    return "C.SWI";
  case OP_SUBI:
    return "SUBI";
  case OP_ADDI:
    return "ADDI";
  case OP_ADDIW:
    return "ADDIW";
  case OP_LWI:
    return "LWI";
  case OP_SWI:
    return "SWI";
  case OP_ADDW:
    return "ADDW";
  case OP_ORW:
    return "ORW";
  case OP_ANDW:
    return "ANDW";
  case OP_XORW:
    return "XORW";
  case OP_CMP_EQ:
    return "CMP.EQ";
  case OP_CSEL:
    return "CSEL";
  case OP_HL_LUI:
    return "HL.LUI";
  case OP_EBREAK:
    return "EBREAK";
  case OP_C_BSTART_COND:
    return "C.BSTART.COND";
  case OP_BSTART_STD_CALL:
    return "BSTART.STD.CALL";
  case OP_C_MOVI:
    return "C.MOVI";
  case OP_C_SETRET:
    return "C.SETRET";
  case OP_C_SETC_EQ:
    return "C.SETC.EQ";
  case OP_C_SETC_TGT:
    return "C.SETC.TGT";
  case OP_ADDTPC:
    return "ADDTPC";
  case OP_SDI:
    return "SDI";
  default:
    return "OP?";
  }
}

enum class UopClass : std::size_t {
  Tload,
  Tstore,
  Matmul,
  Vcall,
  Load,
  Store,
  Alu,
  Br,
  Mul,
  Div,
  Fp,
  Vec,
  Csr,
  Nop,
  Count
};

static UopClass opClass(std::uint32_t op) {
  switch (op) {
  case OP_C_LWI:
  case OP_LWI:
    return UopClass::Load;
  case OP_C_SWI:
  case OP_SWI:
  case OP_SDI:
    return UopClass::Store;
  case OP_C_BSTART_STD:
  case OP_C_BSTART_COND:
  case OP_BSTART_STD_CALL:
  case OP_C_BSTOP:
  case OP_C_SETRET:
  case OP_C_SETC_EQ:
  case OP_C_SETC_TGT:
    return UopClass::Br;
  case OP_EBREAK:
  case OP_INVALID:
    return UopClass::Nop;
  default:
    return UopClass::Alu;
  }
}

struct ReportItem {
  const char *name;
  UopClass cls;
};

static constexpr ReportItem kReportItems[] = {
    {"uops_tload", UopClass::Tload}, {"uops_tstore", UopClass::Tstore}, {"uops_matmul", UopClass::Matmul},
    {"uops_vcall", UopClass::Vcall}, {"uops_load", UopClass::Load},   {"uops_store", UopClass::Store},
    {"uops_alu", UopClass::Alu},     {"uops_br", UopClass::Br},       {"uops_mul", UopClass::Mul},
    {"uops_div", UopClass::Div},     {"uops_fp", UopClass::Fp},       {"uops_vec", UopClass::Vec},
    {"uops_csr", UopClass::Csr},     {"uops_nop", UopClass::Nop},
};

struct ExportOptions {
  bool pipeview_enabled = false;
  bool swimlane_enabled = false;
  std::string pipeview_path = "pipeview.log";
  std::string swimlane_path = "swimlane.trace.json";
};

template <unsigned AddrWidth, unsigned DataWidth, std::size_t DepthBytes>
static bool loadMemh(pyc::cpp::pyc_byte_mem<AddrWidth, DataWidth, DepthBytes> &mem, const std::string &path) {
  std::ifstream f(path);
  if (!f.is_open()) {
    std::cerr << "ERROR: failed to open memh: " << path << "\n";
    return false;
  }

  std::uint64_t addr = 0;
  std::string tok;
  while (f >> tok) {
    if (tok.empty())
      continue;
    if (tok[0] == '@') {
      addr = std::stoull(tok.substr(1), nullptr, 16);
      continue;
    }
    unsigned v = std::stoul(tok, nullptr, 16) & 0xFFu;
    mem.pokeByte(static_cast<std::size_t>(addr), static_cast<std::uint8_t>(v));
    addr++;
  }
  return true;
}

static bool parseBool(const std::string &text, bool *value) {
  if (text == "1" || text == "true" || text == "on") {
    *value = true;
    return true;
  }
  if (text == "0" || text == "false" || text == "off") {
    *value = false;
    return true;
  }
  return false;
}

static void ensureParentDirExists(const std::string &path) {
  std::filesystem::path p(path);
  auto parent = p.parent_path();
  if (!parent.empty()) {
    std::error_code ec;
    std::filesystem::create_directories(parent, ec);
  }
}

static void emitReport(const std::string &program_path, std::uint64_t cycles, std::uint64_t committed,
                       const std::array<std::uint64_t, static_cast<std::size_t>(UopClass::Count)> &uop_counts) {
  std::uint64_t total_uops = 0;
  for (std::uint64_t count : uop_counts) {
    total_uops += count;
  }

  std::cout << "=== LinxISA Report ===\n";
  std::cout << "program: " << program_path << "\n";
  std::cout << "cycles: " << cycles << "\n";
  std::cout << "committed: " << committed << "\n";
  std::cout << "uops_total: " << total_uops << "\n";
  std::cout << "\n-- Uop Breakdown --\n";
  std::cout << std::left << std::setw(14) << "type" << std::right << std::setw(8) << "count" << std::setw(8) << "pct"
            << "\n";
  for (const auto &item : kReportItems) {
    const std::uint64_t count = uop_counts[static_cast<std::size_t>(item.cls)];
    const double pct = total_uops == 0 ? 0.0 : (100.0 * static_cast<double>(count)) / static_cast<double>(total_uops);
    std::cout << std::left << std::setw(14) << item.name << std::right << std::setw(8) << count << std::setw(7)
              << std::fixed << std::setprecision(1) << pct << "\n";
  }
}

static bool runProgram(const char *name, const char *memhPath, std::uint64_t bootPc, std::optional<std::uint32_t> expectedMem100,
                       std::optional<std::uint64_t> expectedA0, const ExportOptions &export_opts) {
  pyc::gen::linx_cpu_pyc dut{};
  if (!loadMemh(dut.mem, memhPath))
    return false;

  dut.boot_pc = Wire<64>(bootPc);
  dut.boot_sp = Wire<64>(kBootSp);

  Testbench<pyc::gen::linx_cpu_pyc> tb(dut);

  const bool trace_log = (std::getenv("PYC_TRACE") != nullptr);
  const bool trace_vcd = (std::getenv("PYC_VCD") != nullptr);
  if (trace_log || trace_vcd) {
    const char *trace_dir_env = std::getenv("PYC_TRACE_DIR");
    std::filesystem::path out_dir =
        trace_dir_env ? std::filesystem::path(trace_dir_env) : std::filesystem::path("examples/generated/linx_cpu_pyc");
    std::filesystem::create_directories(out_dir);

    if (trace_log) {
      tb.enableLog((out_dir / (std::string("tb_linx_cpu_pyc_cpp_") + name + ".log")).string());
      tb.log() << "tb_linx_cpu_pyc(C++): memh=" << memhPath << " boot_pc=0x" << std::hex << bootPc << std::dec << "\n";
    }

    if (trace_vcd) {
      tb.enableVcd((out_dir / (std::string("tb_linx_cpu_pyc_cpp_") + name + ".vcd")).string(), /*top=*/"tb_linx_cpu_pyc_cpp");
      tb.vcdTrace(dut.clk, "clk");
      tb.vcdTrace(dut.rst, "rst");
      tb.vcdTrace(dut.boot_pc, "boot_pc");
      tb.vcdTrace(dut.boot_sp, "boot_sp");
      tb.vcdTrace(dut.halted, "halted");
      tb.vcdTrace(dut.pc, "pc");
      tb.vcdTrace(dut.stage, "stage");
      tb.vcdTrace(dut.cycles, "cycles");
      tb.vcdTrace(dut.if_window, "if_window");
      tb.vcdTrace(dut.wb_op, "wb_op");
      tb.vcdTrace(dut.wb_regdst, "wb_regdst");
      tb.vcdTrace(dut.wb_value, "wb_value");
      tb.vcdTrace(dut.commit_cond, "commit_cond");
      tb.vcdTrace(dut.commit_tgt, "commit_tgt");
      tb.vcdTrace(dut.a0, "a0");
      tb.vcdTrace(dut.a1, "a1");
      tb.vcdTrace(dut.ra, "ra");
      tb.vcdTrace(dut.sp, "sp");
    }
  }

  tb.addClock(dut.clk, /*halfPeriodSteps=*/1);
  tb.reset(dut.rst, /*cyclesAsserted=*/2, /*cyclesDeasserted=*/1);

  std::uint64_t insnCount = 0;
  std::array<std::uint64_t, static_cast<std::size_t>(UopClass::Count)> uop_counts{};
  std::optional<pyc::cpp::PipeviewTimeline> in_flight{};
  std::optional<pyc::cpp::PipeviewStreamWriter> pipeview_writer{};
  std::optional<pyc::cpp::PerfettoTraceWriter> swimlane_writer{};

  if (export_opts.pipeview_enabled) {
    std::string path = export_opts.pipeview_path;
    if (path == "pipeview.log" && name != nullptr && std::string(name) != "program") {
      path = std::string("pipeview_") + name + ".log";
    }
    ensureParentDirExists(path);
    pipeview_writer.emplace();
    if (!pipeview_writer->open(path)) {
      std::cerr << "ERROR: failed to open pipeview: " << path << "\n";
      return false;
    }
    std::cout << "pipeview: " << path << "\n";
  }

  if (export_opts.swimlane_enabled) {
    std::string path = export_opts.swimlane_path;
    if (path == "swimlane.trace.json" && name != nullptr && std::string(name) != "program") {
      path = std::string("swimlane_") + name + ".trace.json";
    }
    ensureParentDirExists(path);
    swimlane_writer.emplace();
    if (!swimlane_writer->open(path)) {
      std::cerr << "ERROR: failed to open swimlane trace: " << path << "\n";
      return false;
    }
    std::cout << "swimlane: " << path << "\n";
  }

  for (std::uint64_t i = 0; i < 200000; i++) {
    const std::uint32_t stage = static_cast<std::uint32_t>(dut.stage.value());
    const bool halted = dut.halted.toBool();
    const std::uint64_t pc = dut.pc.value();
    const std::uint64_t cycle = dut.cycles.value();

    if (!halted) {
      switch (stage) {
      case ST_IF: {
        if (!in_flight.has_value()) {
          in_flight.emplace();
          in_flight->pc = pc;
          in_flight->fetch_cycle = cycle;
        }
        break;
      }
      case ST_ID: {
        if (in_flight.has_value()) {
          in_flight->decode_cycle = cycle;
          in_flight->rename_cycle = cycle;
          in_flight->dispatch_cycle = cycle;
        }
        break;
      }
      case ST_EX: {
        if (in_flight.has_value())
          in_flight->issue_cycle = cycle;
        break;
      }
      case ST_MEM: {
        if (in_flight.has_value())
          in_flight->complete_cycle = cycle;
        break;
      }
      case ST_WB: {
        if (in_flight.has_value()) {
          insnCount++;
          in_flight->id = insnCount;
          in_flight->retire_cycle = cycle;

          const std::uint32_t op = static_cast<std::uint32_t>(dut.wb_op.value());
          uop_counts[static_cast<std::size_t>(opClass(op))]++;
          const std::uint32_t regdst = static_cast<std::uint32_t>(dut.wb_regdst.value());
          const std::uint64_t value = dut.wb_value.value();
          const std::uint64_t window = dut.if_window.value();
          const bool is_store = (op == OP_SWI) || (op == OP_C_SWI) || (op == OP_SDI);
          in_flight->is_store = is_store;

          std::ostringstream name_oss;
          name_oss << opName(op) << " win=0x" << std::hex << window << std::dec;
          if (regdst != 0) {
            name_oss << " rd=" << regdst;
          }
          name_oss << " val=0x" << std::hex << value << std::dec;
          in_flight->name = name_oss.str();

          if (pipeview_writer.has_value()) {
            if (!pipeview_writer->write(*in_flight)) {
              std::cerr << "ERROR: failed to write pipeview event\n";
              return false;
            }
          }
          if (swimlane_writer.has_value()) {
            if (!swimlane_writer->write(*in_flight)) {
              std::cerr << "ERROR: failed to write swimlane event\n";
              return false;
            }
          }
          in_flight.reset();
        }
        break;
      }
      default:
        break;
      }
    }

    if (trace_log && stage == ST_WB && !halted) {
      tb.log() << "[wb #" << std::dec << insnCount << "] pc=0x" << std::hex << dut.pc.value()
               << " win=0x" << dut.if_window.value() << " op=" << std::dec << dut.wb_op.value()
               << " regdst=" << dut.wb_regdst.value() << " value=0x" << std::hex << dut.wb_value.value()
               << " a0=0x" << dut.a0.value() << " a1=0x" << dut.a1.value() << " ra=0x" << dut.ra.value()
               << " sp=0x" << dut.sp.value() << " br_kind=" << std::dec << dut.br_kind.value()
               << " commit_cond=" << dut.commit_cond.value() << " commit_tgt=0x" << std::hex << dut.commit_tgt.value()
               << std::dec << "\n";
    }
    tb.runCycles(1);
    if (dut.halted.toBool())
      break;
  }
  if (!dut.halted.toBool()) {
    std::cerr << "FAIL " << name << ": did not halt (pc=0x" << std::hex << dut.pc.value() << ")\n";
    return false;
  }

  if (expectedA0.has_value()) {
    std::uint64_t got = dut.a0.value();
    if (got != *expectedA0) {
      std::cerr << "FAIL " << name << ": a0=0x" << std::hex << got << " expected 0x" << *expectedA0
                << " (pc=0x" << dut.pc.value() << " a1=0x" << dut.a1.value() << " ra=0x" << dut.ra.value()
                << " sp=0x" << dut.sp.value() << ")" << std::dec << "\n";
      return false;
    }
  }

  std::uint32_t got = dut.mem.peek32(0x100);
  if (expectedMem100.has_value()) {
    if (got != *expectedMem100) {
      std::cerr << "FAIL " << name << ": mem[0x100]=0x" << std::hex << got << " expected 0x" << *expectedMem100
                << std::dec << "\n";
      return false;
    }
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << ")\n";
  } else {
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << " mem[0x100]=0x" << std::hex << got
              << std::dec << ")\n";
  }

  emitReport(memhPath, dut.cycles.value(), insnCount, uop_counts);

  if (export_opts.pipeview_enabled) {
    std::cout << "pipeview: wrote " << insnCount << " events\n";
  }
  if (export_opts.swimlane_enabled) {
    std::cout << "swimlane: wrote " << insnCount << " events\n";
  }

  return true;
}

} // namespace

int main(int argc, char **argv) {
  ExportOptions export_opts{};
  std::optional<std::string> memh{};
  std::optional<std::uint32_t> expectedMem100{};
  std::optional<std::uint64_t> expectedA0{};
  std::optional<std::uint64_t> bootPcOverride{};

  for (int i = 1; i < argc; ++i) {
    std::string arg = argv[i];
    if (arg == "-h" || arg == "--help") {
      std::cout << "Usage:\n"
                   "  tb_linx_cpu_pyc [--memh <file>] [expectedMem100] [expectedA0]\n"
                   "  tb_linx_cpu_pyc <memh> [expectedMem100] [expectedA0]\n"
                   "\n"
                   "Trace export (Konata / Perfetto):\n"
                   "  -p  <0|1>             Enable/disable Konata pipeview (O3PipeView)\n"
                   "  -p1                  Enable Konata pipeview (O3PipeView)\n"
                   "  --pipeview <0|1>      Enable/disable Konata pipeview\n"
                   "  --pipfile <path>      Pipeview output path (default: pipeview.log)\n"
                   "  --swimlane <0|1>      Enable/disable Perfetto swimlane trace\n"
                   "  --swimfile <path>     Swimlane output path (default: swimlane.trace.json)\n"
                   "\n"
                   "Other options:\n"
                   "  --memh <file>         Run a single memh program\n"
                   "  -f <file>             Alias for --memh\n"
                   "  --expected <hex>      Expected mem[0x100] (hex or dec)\n"
                   "  --expected-a0 <hex>   Expected a0 (hex or dec)\n"
                   "  --boot-pc <hex>       Override boot PC (also supports PYC_BOOT_PC env)\n";
      return 0;
    }

    if ((arg == "--pipeview" || arg == "-p") && i + 1 < argc) {
      parseBool(argv[++i], &export_opts.pipeview_enabled);
      continue;
    }
    if (arg == "-p1") {
      export_opts.pipeview_enabled = true;
      continue;
    }
    if (arg == "--pipfile" && i + 1 < argc) {
      export_opts.pipeview_path = argv[++i];
      continue;
    }
    if (arg == "--swimlane" && i + 1 < argc) {
      parseBool(argv[++i], &export_opts.swimlane_enabled);
      continue;
    }
    if (arg == "--swimfile" && i + 1 < argc) {
      export_opts.swimlane_path = argv[++i];
      continue;
    }
    if ((arg == "--memh" || arg == "-f") && i + 1 < argc) {
      memh = argv[++i];
      continue;
    }
    if (arg == "--expected" && i + 1 < argc) {
      expectedMem100 = static_cast<std::uint32_t>(std::stoul(argv[++i], nullptr, 0));
      continue;
    }
    if (arg == "--expected-a0" && i + 1 < argc) {
      expectedA0 = static_cast<std::uint64_t>(std::stoull(argv[++i], nullptr, 0));
      continue;
    }
    if (arg == "--boot-pc" && i + 1 < argc) {
      bootPcOverride = static_cast<std::uint64_t>(std::stoull(argv[++i], nullptr, 0));
      continue;
    }

    if (!arg.empty() && arg[0] == '-') {
      std::cerr << "error: unknown argument: " << arg << "\n";
      return 2;
    }

    // Positional (backwards compatible with the existing scripts):
    //   <memh> [expectedMem100] [expectedA0]
    if (!memh.has_value()) {
      memh = arg;
      continue;
    }
    if (!expectedMem100.has_value()) {
      expectedMem100 = static_cast<std::uint32_t>(std::stoul(arg, nullptr, 0));
      continue;
    }
    if (!expectedA0.has_value()) {
      expectedA0 = static_cast<std::uint64_t>(std::stoull(arg, nullptr, 0));
      continue;
    }
    std::cerr << "error: extra positional argument: " << arg << "\n";
    return 2;
  }

  std::uint64_t bootPc = kBootPc;
  if (bootPcOverride.has_value()) {
    bootPc = *bootPcOverride;
  } else if (const char *env = std::getenv("PYC_BOOT_PC")) {
    bootPc = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
  }

  if (memh.has_value()) {
    return runProgram("program", memh->c_str(), bootPc, expectedMem100, expectedA0, export_opts) ? 0 : 1;
  }

  // Default regression tests (memh fixtures checked into the repo).
  if (!runProgram("test_csel_fixed", "examples/linx_cpu/programs/test_csel_fixed.memh", bootPc, /*expectedMem100=*/100u, /*expectedA0=*/{},
                  export_opts))
    return 1;
  if (!runProgram("test_or", "examples/linx_cpu/programs/test_or.memh", bootPc, /*expectedMem100=*/0x0000FF00u, /*expectedA0=*/{}, export_opts))
    return 1;

  if (!runProgram("test_branch2", "examples/linx_cpu/programs/test_branch2.memh", /*bootPc=*/bootPc + 0x0a, /*expectedMem100=*/{},
                  /*expectedA0=*/8u, export_opts))
    return 1;
  if (!runProgram("test_call_simple", "examples/linx_cpu/programs/test_call_simple.memh", /*bootPc=*/bootPc + 0x1c,
                  /*expectedMem100=*/{}, /*expectedA0=*/42u, export_opts))
    return 1;
  if (!runProgram("test_jump", "examples/linx_cpu/programs/test_jump.memh", bootPc, /*expectedMem100=*/{}, /*expectedA0=*/42u, export_opts))
    return 1;
  if (!runProgram("test_pcrel", "examples/linx_cpu/programs/test_pcrel.memh", bootPc, /*expectedMem100=*/{}, /*expectedA0=*/43u, export_opts))
    return 1;
  return 0;
}

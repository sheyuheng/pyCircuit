#pragma once

#include <cstdint>
#include <fstream>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

#include "pyc_bits.hpp"

namespace pyc::cpp {

class VcdWriter {
public:
  VcdWriter() = default;

  bool open(const std::string &path, const std::string &top = "tb", const std::string &timescale = "1ns") {
    out_.open(path, std::ios::out | std::ios::trunc);
    if (!out_.is_open())
      return false;

    out_ << "$date\n  (generated by pyCircuit)\n$end\n";
    out_ << "$version\n  pyCircuit C++ TB\n$end\n";
    out_ << "$timescale " << timescale << " $end\n";
    out_ << "$scope module " << sanitizeName(top) << " $end\n";
    finalized_ = false;
    cur_time_ = ~std::uint64_t{0};
    sigs_.clear();
    return true;
  }

  bool isOpen() const { return out_.is_open(); }

  template <unsigned W>
  bool add(Wire<W> &w, const std::string &name) {
    if (!out_.is_open() || finalized_)
      return false;
    SignalDef d;
    d.width = W;
    d.words = (W + 63u) / 64u;
    d.name = sanitizeName(name);
    d.id = makeId(sigs_.size());
    d.ptr = &w;
    d.read = &readWords<W>;
    d.has_last = false;
    d.last.resize(d.words, 0);
    out_ << "$var wire " << d.width << " " << d.id << " " << d.name << " $end\n";
    sigs_.push_back(std::move(d));
    return true;
  }

  void dump(std::uint64_t time) {
    if (!out_.is_open())
      return;
    if (!finalized_) {
      out_ << "$upscope $end\n";
      out_ << "$enddefinitions $end\n";
      // Initial values at time 0.
      out_ << "#0\n";
      for (auto &s : sigs_) {
        s.read(s.ptr, s.last.data());
        emitValue(out_, s.width, s.last, s.id);
        s.has_last = true;
      }
      finalized_ = true;
      cur_time_ = 0;
    }

    if (time != cur_time_) {
      out_ << "#" << time << "\n";
      cur_time_ = time;
    }

    std::vector<std::uint64_t> tmp{};
    for (auto &s : sigs_) {
      tmp.assign(s.words, 0);
      s.read(s.ptr, tmp.data());
      if (!s.has_last || tmp != s.last) {
        emitValue(out_, s.width, tmp, s.id);
        s.last = tmp;
        s.has_last = true;
      }
    }
  }

private:
  struct SignalDef {
    unsigned width = 1;
    unsigned words = 1;
    std::string name{};
    std::string id{};
    const void *ptr = nullptr;
    void (*read)(const void *, std::uint64_t *) = nullptr;
    bool has_last = false;
    std::vector<std::uint64_t> last{};
  };

  static std::string sanitizeName(const std::string &s) {
    std::string out = s;
    for (char &c : out) {
      if (c == ' ' || c == '\t' || c == '\n' || c == '\r')
        c = '_';
    }
    if (out.empty())
      out = "sig";
    return out;
  }

  static std::string makeId(std::size_t idx) {
    // Printable non-space ASCII is generally accepted in VCD identifiers.
    static constexpr char kAlphabet[] =
        "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    static constexpr std::size_t kBase = sizeof(kAlphabet) - 1;
    std::string out;
    do {
      out.push_back(kAlphabet[idx % kBase]);
      idx /= kBase;
    } while (idx != 0);
    return out;
  }

  static void emitValue(std::ostream &os, unsigned width, const std::vector<std::uint64_t> &words, const std::string &id) {
    if (width <= 1) {
      os << (((words.empty() ? 0u : words[0]) & 1u) ? '1' : '0') << id << "\n";
      return;
    }
    os << 'b';
    for (int b = static_cast<int>(width) - 1; b >= 0; --b) {
      unsigned bi = static_cast<unsigned>(b);
      unsigned wi = bi / 64u;
      unsigned bj = bi % 64u;
      std::uint64_t w = (wi < words.size()) ? words[wi] : 0u;
      os << (((w >> bj) & 1u) ? '1' : '0');
    }
    os << ' ' << id << "\n";
  }

  template <unsigned W>
  static void readWords(const void *p, std::uint64_t *dst) {
    constexpr unsigned words = (W + 63u) / 64u;
    const auto *w = static_cast<const Wire<W> *>(p);
    for (unsigned i = 0; i < words; i++)
      dst[i] = w->word(i);
  }

  std::ofstream out_{};
  std::vector<SignalDef> sigs_{};
  bool finalized_ = false;
  std::uint64_t cur_time_ = ~std::uint64_t{0};
};

} // namespace pyc::cpp

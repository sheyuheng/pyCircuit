#include <cstdint>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <string>

#include <pyc/cpp/pyc_tb.hpp>

// Generated by `pyc-compile --emit=cpp`.
#include "janus_bcc_ooo_pyc_gen.hpp"

using pyc::cpp::Testbench;
using pyc::cpp::Wire;

namespace {

constexpr std::uint64_t kBootPc = 0x0000'0000'0001'0000ull;
constexpr std::uint64_t kBootSp = 0x0000'0000'0002'0000ull;

template <unsigned AddrWidth, unsigned DataWidth, std::size_t DepthBytes>
static bool loadMemh(pyc::cpp::pyc_byte_mem<AddrWidth, DataWidth, DepthBytes> &mem, const std::string &path) {
  std::ifstream f(path);
  if (!f.is_open()) {
    std::cerr << "ERROR: failed to open memh: " << path << "\n";
    return false;
  }

  std::uint64_t addr = 0;
  std::string tok;
  while (f >> tok) {
    if (tok.empty())
      continue;
    if (tok[0] == '@') {
      addr = std::stoull(tok.substr(1), nullptr, 16);
      continue;
    }
    unsigned v = std::stoul(tok, nullptr, 16) & 0xFFu;
    mem.pokeByte(static_cast<std::size_t>(addr), static_cast<std::uint8_t>(v));
    addr++;
  }
  return true;
}

static bool runProgram(const char *name, const char *memhPath, std::uint64_t bootPc, std::optional<std::uint32_t> expectedMem100,
                       std::optional<std::uint64_t> expectedA0) {
  pyc::gen::janus_bcc_ooo_pyc dut{};
  if (!loadMemh(dut.mem, memhPath))
    return false;

  dut.boot_pc = Wire<64>(bootPc);
  dut.boot_sp = Wire<64>(kBootSp);

  Testbench<pyc::gen::janus_bcc_ooo_pyc> tb(dut);

  const bool trace_log = (std::getenv("PYC_TRACE") != nullptr);
  const bool trace_verbose = (std::getenv("PYC_TRACE_VERBOSE") != nullptr);
  const bool trace_vcd = (std::getenv("PYC_VCD") != nullptr);
  if (trace_log || trace_vcd) {
    const char *trace_dir_env = std::getenv("PYC_TRACE_DIR");
    std::filesystem::path out_dir = trace_dir_env ? std::filesystem::path(trace_dir_env) : std::filesystem::path("janus/generated/janus_bcc_ooo_pyc");
    std::filesystem::create_directories(out_dir);

    if (trace_log) {
      tb.enableLog((out_dir / (std::string("tb_janus_bcc_ooo_pyc_cpp_") + name + ".log")).string());
      tb.log() << "tb_janus_bcc_ooo_pyc(C++): memh=" << memhPath << " boot_pc=0x" << std::hex << bootPc << std::dec << "\n";
    }

    if (trace_vcd) {
      tb.enableVcd((out_dir / (std::string("tb_janus_bcc_ooo_pyc_cpp_") + name + ".vcd")).string(), /*top=*/"tb_janus_bcc_ooo_pyc_cpp");
      tb.vcdTrace(dut.clk, "clk");
      tb.vcdTrace(dut.rst, "rst");
      tb.vcdTrace(dut.boot_pc, "boot_pc");
      tb.vcdTrace(dut.boot_sp, "boot_sp");
      tb.vcdTrace(dut.halted, "halted");
      tb.vcdTrace(dut.pc, "pc");
      tb.vcdTrace(dut.fpc, "fpc");
      tb.vcdTrace(dut.cycles, "cycles");
      tb.vcdTrace(dut.commit_fire, "commit_fire");
      tb.vcdTrace(dut.commit_op, "commit_op");
      tb.vcdTrace(dut.commit_value, "commit_value");
      tb.vcdTrace(dut.commit_dst_kind, "commit_dst_kind");
      tb.vcdTrace(dut.commit_dst_areg, "commit_dst_areg");
      tb.vcdTrace(dut.commit_pdst, "commit_pdst");
      tb.vcdTrace(dut.rob_count, "rob_count");
      tb.vcdTrace(dut.a0, "a0");
      tb.vcdTrace(dut.a1, "a1");
      tb.vcdTrace(dut.ra, "ra");
      tb.vcdTrace(dut.sp, "sp");
      tb.vcdTrace(dut.ct0, "ct0");
      tb.vcdTrace(dut.cu0, "cu0");
      tb.vcdTrace(dut.st0, "st0");
      tb.vcdTrace(dut.su0, "su0");
      tb.vcdTrace(dut.issue_fire, "issue_fire");
      tb.vcdTrace(dut.issue_op, "issue_op");
      tb.vcdTrace(dut.issue_pc, "issue_pc");
      tb.vcdTrace(dut.issue_rob, "issue_rob");
      tb.vcdTrace(dut.issue_sl, "issue_sl");
      tb.vcdTrace(dut.issue_sr, "issue_sr");
      tb.vcdTrace(dut.issue_sp, "issue_sp");
      tb.vcdTrace(dut.issue_pdst, "issue_pdst");
      tb.vcdTrace(dut.issue_sl_val, "issue_sl_val");
      tb.vcdTrace(dut.issue_sr_val, "issue_sr_val");
      tb.vcdTrace(dut.issue_sp_val, "issue_sp_val");
      tb.vcdTrace(dut.issue_is_load, "issue_is_load");
      tb.vcdTrace(dut.issue_is_store, "issue_is_store");
      tb.vcdTrace(dut.store_pending, "store_pending");
      tb.vcdTrace(dut.store_pending_older, "store_pending_older");
      tb.vcdTrace(dut.mem_raddr, "mem_raddr");
      tb.vcdTrace(dut.dispatch_fire, "dispatch_fire");
      tb.vcdTrace(dut.dec_op, "dec_op");
    }
  }

  tb.addClock(dut.clk, /*halfPeriodSteps=*/1);
  tb.reset(dut.rst, /*cyclesAsserted=*/2, /*cyclesDeasserted=*/1);

  std::uint64_t commitCount = 0;
  std::uint64_t issueCount = 0;
  std::uint64_t dispatchCount = 0;

  for (std::uint64_t i = 0; i < 400000; i++) {
    if (trace_verbose && dut.dispatch_fire.toBool() && !dut.halted.toBool()) {
      dispatchCount++;
      tb.log() << "[disp #" << std::dec << dispatchCount << "] fpc=0x" << std::hex << dut.fpc.value() << " dec_op=" << std::dec << dut.dec_op.value()
               << "\n";
    }
    if (trace_verbose && dut.issue_fire.toBool() && !dut.halted.toBool()) {
      issueCount++;
      tb.log() << "[issue #" << std::dec << issueCount << "] pc=0x" << std::hex << dut.issue_pc.value() << " op=" << std::dec << dut.issue_op.value()
               << " rob=" << dut.issue_rob.value() << " sl=" << dut.issue_sl.value() << " sr=" << dut.issue_sr.value() << " sp=" << dut.issue_sp.value()
               << " pdst=" << dut.issue_pdst.value() << " slv=0x" << std::hex << dut.issue_sl_val.value() << " srv=0x" << dut.issue_sr_val.value()
               << " spv=0x" << dut.issue_sp_val.value() << std::dec << " is_load=" << dut.issue_is_load.value() << " is_store=" << dut.issue_is_store.value()
               << " store_pending=" << dut.store_pending.value() << " store_pending_older=" << dut.store_pending_older.value() << " mem_raddr=0x" << std::hex
               << dut.mem_raddr.value() << std::dec << "\n";
    }
    if (trace_log && dut.commit_fire.toBool() && !dut.halted.toBool()) {
      commitCount++;
      tb.log() << "[commit #" << std::dec << commitCount << "] pc=0x" << std::hex << dut.pc.value() << " op=" << std::dec << dut.commit_op.value()
               << " val=0x" << std::hex << dut.commit_value.value() << std::dec << " dstk=" << dut.commit_dst_kind.value()
               << " areg=" << dut.commit_dst_areg.value() << " pdst=" << dut.commit_pdst.value() << " a0=0x" << std::hex << dut.a0.value()
               << " ct0=0x" << dut.ct0.value() << " cu0=0x" << dut.cu0.value() << " st0=0x" << dut.st0.value() << " su0=0x" << dut.su0.value()
               << " sp=0x" << dut.sp.value() << std::dec << " rob_count=" << dut.rob_count.value() << "\n";
    }
    tb.runCycles(1);
    if (dut.halted.toBool())
      break;
  }
  if (!dut.halted.toBool()) {
    std::cerr << "FAIL " << name << ": did not halt (pc=0x" << std::hex << dut.pc.value() << " fpc=0x" << dut.fpc.value() << ")\n";
    return false;
  }

  if (expectedA0.has_value()) {
    std::uint64_t got = dut.a0.value();
    if (got != *expectedA0) {
      std::cerr << "FAIL " << name << ": a0=0x" << std::hex << got << " expected 0x" << *expectedA0 << std::dec << "\n";
      return false;
    }
  }

  std::uint32_t got = dut.mem.peek32(0x100);
  if (expectedMem100.has_value()) {
    if (got != *expectedMem100) {
      std::cerr << "FAIL " << name << ": mem[0x100]=0x" << std::hex << got << " expected 0x" << *expectedMem100 << std::dec << "\n";
      return false;
    }
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << ")\n";
  } else {
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << " mem[0x100]=0x" << std::hex << got << std::dec << ")\n";
  }
  return true;
}

} // namespace

int main(int argc, char **argv) {
  if (argc >= 2) {
    const char *memh = argv[1];
    std::optional<std::uint32_t> expectedMem100{};
    std::optional<std::uint64_t> expectedA0{};
    if (argc >= 3)
      expectedMem100 = static_cast<std::uint32_t>(std::stoul(argv[2], nullptr, 0));
    if (argc >= 4)
      expectedA0 = static_cast<std::uint64_t>(std::stoull(argv[3], nullptr, 0));
    std::uint64_t bootPc = kBootPc;
    if (const char *env = std::getenv("PYC_BOOT_PC")) {
      bootPc = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
    }
    return runProgram("program", memh, bootPc, expectedMem100, expectedA0) ? 0 : 1;
  }

  // Default regression tests (memh fixtures checked into this repo).
  if (!runProgram("test_csel_fixed", "janus/programs/test_csel_fixed.memh", kBootPc, /*expectedMem100=*/100u, /*expectedA0=*/{}))
    return 1;
  if (!runProgram("test_or", "janus/programs/test_or.memh", kBootPc, /*expectedMem100=*/0x0000FF00u, /*expectedA0=*/{}))
    return 1;
  if (!runProgram("test_store100_llvm", "janus/programs/test_store100_llvm.memh", kBootPc, /*expectedMem100=*/100u, /*expectedA0=*/{}))
    return 1;

  if (!runProgram("test_branch2", "janus/programs/test_branch2.memh", /*bootPc=*/kBootPc + 0x0a, /*expectedMem100=*/{}, /*expectedA0=*/8u))
    return 1;
  if (!runProgram("test_call_simple", "janus/programs/test_call_simple.memh", /*bootPc=*/kBootPc + 0x1c, /*expectedMem100=*/{}, /*expectedA0=*/42u))
    return 1;
  if (!runProgram("test_jump", "janus/programs/test_jump.memh", kBootPc, /*expectedMem100=*/{}, /*expectedA0=*/42u))
    return 1;
  if (!runProgram("test_pcrel", "janus/programs/test_pcrel.memh", kBootPc, /*expectedMem100=*/{}, /*expectedA0=*/43u))
    return 1;
  return 0;
}
